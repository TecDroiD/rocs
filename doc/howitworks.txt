How it works
============

Rocs consists of several agents which react on messages sent via a queue system. 
a message consists of a textual id, an optional sender id and data, which is commonly json

#define ROCS_IDSIZE		256
#define ROCS_MESSAGESIZE 	1000
#define ROCS_CLIENTNAMESIZE 20

/**
 * data type for the standard message
 */
typedef struct s_rocsmq_message {
	char id[ROCS_IDSIZE];
	char sender[ROCS_CLIENTNAMESIZE];
	char tail[ROCS_MESSAGESIZE];
} t_rocsmq_message, *p_rocsmq_message;


Agents are organized as loosely connected circle.
  
        +------------->[Logic-Agents]------------------+
        |                    ^                         |
        |                    |                         |
        |                    v                         v
[Interpreter]<----------[cron-Agent]<------------->[Planner]
        ^                    |                         ^
        |                    |                         |
	    |                    v                         |
	    +---[Hardware-Agents, i2c, can, spi*, gpio*]<--+
	    

Interpreter, Planner and Logic-Agents are scripting agents. Actually, lua is used.

The idea behind that is to interprete hardware information into abstract world data which can be reacted on by logic agents. 
Logic agents calculate an abstract reaction (eg. walk, stand still, speak, ...).  Therefore, they are reuseable.
These reactions are received by planners who create hardware dependant steps which are sent to corresponding hardware agents. 
Planners are also able to receive information from hardware agents for direct feedback.

