Behaviour is designed by creating atomic reactions on inputs for the logic agent. 
This may be:

bumped into obstacle -> turn around

Seems simple. The first tricky part is how to know what "bumped into obstacle" means. Therefore, a hardware agent has to send a message like

"sensor.gpio" 
{ 
   "data" :  01,
   "changed" : 01,
}

which would mean that pin 1 has changed from low to high level. Now, an interpreter script has to regognize the input and to format it into an event matching the world image of the roboter. 

JSON = require "JSON"

-- lua script to recognize a bump
-- we suppose, that message is "sensor.gpio"
function run (message, json) 
   local jsonTree = JSON.decode(json)

   -- pin 0 and 1 are front bumpers
   if jsonTree["changed"] > 0 && jsonTree["changed"] < 3 
   then
      data = jsonTree["data"]
      if data == 1 
      then
         send_message("input.bump","{\"direction\":\"front-left\"}")
      else if data == 2 
      then
         send_message("input.bump","{\"direction\":\"front-right\"}")
      else if data == 3 
      then
         send_message("input.bump","{\"direction\":\"front\"}")
      end
   end
end -- run

next, a logic script has to react on that data

JSON = require "JSON"

-- lua script to react on a bump
-- we suppose, that message is "input.bump"
function run (message, json) 
   local jsonTree = JSON.decode(json)
   
   if jsonTree["direction"] == "front"
   then
         send_message("move.surround","{\"direction\":\"left\"}")
   else if jsonTree["direction"] == "front-left"
   then
         send_message("move.surround","{\"direction\":\"right\"}")
   else if jsonTree["direction"] == "front-right"
   then
         send_message("move.surround","{\"direction\":\"left\"}")
   else

end -- run

Now we know what to do. Now we need to learn, how to do this.
a turn should be something like

run backward -> turn a little -> send done.

could be worse, or not? There are several ways to implement this, depending on the underlying hardware. If hardware is able to response when a predefined action has been done, it is just a simple state machine where the received message gives the state.

JSON = require "JSON"

-- stays to define...
CAN_MESSAGE_ID_DONE = 20

-- formats a movement for two motors
function format_can_movement(motora, motorb)
   -- to be implemented...
end

-- lua planner to surround with responding hardware
function run(message, json) 
   local jsonTree = JSON.decode(json)

   -- get proces state
   action = retrieve("action")
   direction = retrieve("direction")
   state = retrieve("state")

   if message == "move.surround" 
   then
   -- start movement
      persist("action", message)
      persist("direction", jsonTree["direction"])
      persist("state", "start")

      -- drive backward for 10 cm
      send_message("can.send", format_can_movement(-100,-100))

   else if message == "sensor.can" && action == "move.surround"
   then
      if jsonTree["messageid"] == CAN_MESSAGE_ID_DONE
      then
         if state == "start"
         then
            -- turn around
            persist("state", "turn")
            if direction == "left" 
            then
               -- turn left, left motor 5cm backward, right motor 5cm forward
               send_message("can.send", format_can_movement(-50,50))
            else
               -- turn right, left motor 5cm forward, right motor 5cm backward
               send_message("can.send", format_can_movement(-50,50))
            end
         else if state == "turn"
         then
            -- end movement
            -- stop state
            persist("action", "idle")
            persist("direction", "")
            persist("state", "")
         end
      end
   end
end -- run

If hardware cannot response, a timer process can be sent.

CRON = require "cronhelper"
JSON = require "JSON"

-- formats data for motor movement
function format_gpio_motor (motora, motorb) 
  -- to implement
end
-- lua planner to surround without responding hardware
function run(message, json) 
   local jsonTree = JSON.decode(json)

   action = retrieve("action")
   direction = retrieve("direction")
 
   if message == "move.surround" 
   then
      -- start movement process
      persist("action", message)
      persist("direction", jsonTree["direction"])

      -- move backward for 2 s
      send_message("gpio.set", format_gpio_motor(-1,-1))
      -- set cron to stop motors
      CRON.start("move.surround.turn",20,1, "{}")

   else if message == "move.surround.turn"
      -- now turn
      if direction == "left"
      then
         -- turn left: move left motor backward and right motor forward
         send_message("gpio.set", format_gpio_motor(-1,1))
      else
         -- turn right: move left motor forward and right motor backward
         send_message("gpio.set", format_gpio_motor(1,-1))
      end
      -- wait 2 seconds
      CRON.start("move.surround.stop",20,1, "{}")
  else if message == "move.surround.stop"
         -- stop motors
         send_message("gpio.set", format_gpio_motor(0,0))
         -- set idle
         persist("action","idle")
         persist("direction", "")
   end
end -- run

now, the first behaviour is done.

Sadly, the robot wouldn't do anything unless someone bumps it. So, a start message should be sent. let's say, the robot runs forward until something happens..


CRON = require "cronhelper"

-- standard run will run all 10 seconds
function run(message,json) 
   action = retrieve("action")
 
   -- if nothing else has to be done
   if action == "idle"
   then
     -- move both motors forward
     send_message("gpio.set", format_gpio_motor(1,1))
     -- ask again in 10 seconds
     CRON.start("idle", 100, 1, "{}")
   end      
end -- run

